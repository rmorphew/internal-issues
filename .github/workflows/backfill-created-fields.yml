name: Backfill Project Created By/At

on:
  workflow_dispatch: {}

permissions:
  contents: read
  issues: read

env:
  # (Recommended) put your ProjectV2 node id here to skip lookup by title:
  # PROJECT_ID: PVT_kwHOAgVoGc4BC4my
  PROJECT_OWNER: rmorphew
  PROJECT_TITLE: Issue Tracker
  FIELD_CREATED_BY: Created By
  FIELD_CREATED_AT: Created At

jobs:
  backfill:
    runs-on: ubuntu-latest
    steps:
      - name: Resolve Project + Field IDs (paginated)
        id: meta
        env:
          GH_TOKEN: ${{ secrets.PROJECTS_PAT }}   # classic PAT: repo, workflow, project
        run: |
          set -euo pipefail

          # 1) Project id (prefer env.PROJECT_ID; else lookup)
          if [ -n "${PROJECT_ID:-}" ]; then
            pid="$PROJECT_ID"
            echo "Using PROJECT_ID from env: $pid"
          else
            echo "Looking up project '${PROJECT_TITLE}' for user '${PROJECT_OWNER}'"
            q1='query($login:String!){
              user(login:$login){ projectsV2(first:100){ nodes{ id title } } }
            }'
            body=$(jq -n --arg q "$q1" --arg login "$PROJECT_OWNER" '{query:$q,variables:{login:$login}}')
            resp=$(curl -sS -H "Authorization: Bearer $GH_TOKEN" -d "$body" https://api.github.com/graphql)
            if jq -e 'has("errors")' >/dev/null <<<"$resp"; then
              echo "::error::GraphQL errors during project lookup:"; jq -C '.errors' <<<"$resp"; exit 1
            fi
            pid=$(jq -r --arg t "$PROJECT_TITLE" '.data.user.projectsV2.nodes[]? | select(.title==$t) | .id' <<<"$resp")
            [ -n "$pid" ] || { echo "::error::Project '$PROJECT_TITLE' not found for $PROJECT_OWNER"; exit 1; }
          fi
          echo "project_id=$pid" >> "$GITHUB_OUTPUT"
          echo "Resolved project id: $pid"

          # 2) Paginate fields(first:100)
          read -r -d '' Q_FIELDS <<'EOF'
          query($id:ID!, $after:String){
            node(id:$id){
              ... on ProjectV2{
                fields(first:100, after:$after){
                  nodes{
                    __typename
                    ... on ProjectV2FieldCommon { id name dataType }
                  }
                  pageInfo{ hasNextPage endCursor }
                }
              }
            }
          }
          EOF

          want_by="${FIELD_CREATED_BY:-Created By}"
          want_at="${FIELD_CREATED_AT:-Created At}"
          by_id=""; at_id=""; at_dtype=""; after=""

          echo "Scanning fields (paginated) looking for: '$want_by' (TEXT), '$want_at' (DATE/TEXT)"

          while : ; do
            # build variables with optional cursor
            if [ -n "$after" ]; then
              vars=$(jq -n --arg id "$pid" --arg after "$after" '{id:$id, after:$after}')
            else
              vars=$(jq -n --arg id "$pid" '{id:$id}')
            fi
            body=$(jq -n --arg q "$Q_FIELDS" --argjson v "$vars" '{query:$q,variables:$v}')
            resp=$(curl -sS -H "Authorization: Bearer $GH_TOKEN" -d "$body" https://api.github.com/graphql)

            if jq -e 'has("errors")' >/dev/null <<<"$resp"; then
              echo "::error::GraphQL errors during field fetch:"; jq -C '.errors' <<<"$resp"; exit 1
            fi

            # print this page (for visibility)
            jq -C '.data.node.fields.nodes[]? | {name,dataType,id}' <<<"$resp"

            # try to capture IDs from this page
            if [ -z "$by_id" ]; then
              by_id=$(jq -r --arg n "$want_by" '.data.node.fields.nodes[]? | select(.name==$n and .dataType=="TEXT") | .id // empty' <<<"$resp")
            fi
            if [ -z "$at_id" ]; then
              at_id=$(jq -r --arg n "$want_at" '.data.node.fields.nodes[]? | select(.name==$n and (.dataType=="DATE" or .dataType=="TEXT")) | .id // empty' <<<"$resp")
              if [ -n "$at_id" ]; then
                at_dtype=$(jq -r --arg n "$want_at" '.data.node.fields.nodes[]? | select(.name==$n and (.dataType=="DATE" or .dataType=="TEXT")) | .dataType' <<<"$resp")
              fi
            fi

            hasNext=$(jq -r '.data.node.fields.pageInfo.hasNextPage' <<<"$resp")
            after=$(jq -r '.data.node.fields.pageInfo.endCursor // ""' <<<"$resp")

            # stop if both found or no more pages
            if { [ -n "$by_id" ] && [ -n "$at_id" ]; } || [ "$hasNext" != "true" ]; then
              break
            fi
          done

          [ -n "$by_id" ] || echo "::warning::Field '$want_by' (TEXT) not found."
          if [ -z "$at_id" ]; then
            echo "::warning::Field '$want_at' (DATE/TEXT) not found."
          fi

          echo "by_field=${by_id:-}"       >> "$GITHUB_OUTPUT"
          echo "at_field=${at_id:-}"       >> "$GITHUB_OUTPUT"
          echo "at_dtype=${at_dtype:-}"    >> "$GITHUB_OUTPUT"
          echo "Resolved → Created By: ${by_id:-<missing>}, Created At: ${at_id:-<missing>} (type ${at_dtype:-n/a})"

      - name: Backfill missing values
        if: ${{ steps.meta.outputs.project_id != '' }}
        env:
          GH_TOKEN:   ${{ secrets.PROJECTS_PAT }}
          PROJECT_ID: ${{ steps.meta.outputs.project_id }}
          BY_FIELD:   ${{ steps.meta.outputs.by_field }}
          AT_FIELD:   ${{ steps.meta.outputs.at_field }}
          AT_DTYPE:   ${{ steps.meta.outputs.at_dtype }}
        run: |
          set -euo pipefail
          echo "Starting backfill for project $PROJECT_ID"

          read -r -d '' Q_ITEMS <<'EOF'
          query($pid:ID!, $after:String){
            node(id:$pid){
              ... on ProjectV2{
                items(first:50, after:$after){
                  nodes{
                    id
                    content{
                      __typename
                      ... on Issue { id number createdAt author { login } }
                    }
                    fieldValues(first:20){
                      nodes{
                        __typename
                        field { ... on ProjectV2FieldCommon { name } }
                        ... on ProjectV2ItemFieldTextValue { text }
                        ... on ProjectV2ItemFieldDateValue { date }
                      }
                    }
                  }
                  pageInfo{ hasNextPage endCursor }
                }
              }
            }
          }
          EOF

          UPDATE_MUT='mutation($input:UpdateProjectV2ItemFieldValueInput!){
            updateProjectV2ItemFieldValue(input:$input){ projectV2Item { id } }
          }'

          after=""
          scanned=0
          updated=0

          while : ; do
            if [ -n "$after" ]; then
              vars=$(jq -n --arg pid "$PROJECT_ID" --arg after "$after" '{pid:$pid, after:$after}')
            else
              vars=$(jq -n --arg pid "$PROJECT_ID" '{pid:$pid}')
            fi
            body=$(jq -n --arg q "$Q_ITEMS" --argjson v "$vars" '{query:$q,variables:$v}')
            resp=$(curl -sS -H "Authorization: Bearer $GH_TOKEN" -d "$body" https://api.github.com/graphql)

            if jq -e 'has("errors")' >/dev/null <<<"$resp"; then
              echo "::error::GraphQL errors while listing items:"
              jq -C '.errors' <<<"$resp"
              echo "::group::Full response"; jq -C . <<<"$resp"; echo "::endgroup::"
              exit 1
            fi

            if [ "$(jq -r '.data.node.items | type' <<<"$resp")" != "object" ]; then
              echo "::warning::Project items were null (token likely lacks 'project' scope on classic PAT)."
              echo "::group::Full response"; jq -C . <<<"$resp"; echo "::endgroup::"
              break
            fi

            hasNext=$(jq -r '.data.node.items.pageInfo.hasNextPage' <<<"$resp")
            after=$(jq -r '.data.node.items.pageInfo.endCursor // ""' <<<"$resp")

            jq -c '.data.node.items.nodes[]' <<<"$resp" | while read -r node; do
              scanned=$((scanned+1))
              type=$(jq -r '.content.__typename' <<<"$node")
              [ "$type" = "Issue" ] || continue

              itemId=$(jq -r '.id' <<<"$node")
              author=$(jq -r '.content.author.login // empty' <<<"$node")
              created=$(jq -r '.content.createdAt[0:10] // empty' <<<"$node")

              haveBy=$(jq -r --arg n "Created By" '.fieldValues.nodes[]? | select(.field.name==$n) | (.text // "")' <<<"$node" | head -n1)
              haveAtDate=$(jq -r --arg n "Created At" '.fieldValues.nodes[]? | select(.field.name==$n and .__typename=="ProjectV2ItemFieldDateValue") | (.date // "")' <<<"$node" | head -n1)
              haveAtText=$(jq -r --arg n "Created At" '.fieldValues.nodes[]? | select(.field.name==$n and .__typename=="ProjectV2ItemFieldTextValue") | (.text // "")' <<<"$node" | head -n1)

              # Created By (TEXT)
              if [ -n "${BY_FIELD:-}" ] && [ -n "$author" ] && [ -z "$haveBy" ]; then
                payload=$(jq -n --arg q "$UPDATE_MUT" \
                             --arg pid "$PROJECT_ID" --arg iid "$itemId" --arg fid "$BY_FIELD" --arg v "$author" \
                             '{query:$q,variables:{input:{projectId:$pid,itemId:$iid,fieldId:$fid,value:{text:$v}}}}')
                curl -sS -H "Authorization: Bearer $GH_TOKEN" -d "$payload" https://api.github.com/graphql > /dev/null
                updated=$((updated+1)); echo "Set Created By → $author"
              fi

              # Created At (DATE preferred; else TEXT)
              if [ -n "${AT_FIELD:-}" ] && [ -n "$created" ]; then
                if [ "${AT_DTYPE:-}" = "DATE" ] && [ -z "$haveAtDate" ]; then
                  payload=$(jq -n --arg q "$UPDATE_MUT" \
                               --arg pid "$PROJECT_ID" --arg iid "$itemId" --arg fid "$AT_FIELD" --arg v "$created" \
                               '{query:$q,variables:{input:{projectId:$pid,itemId:$iid,fieldId:$fid,value:{date:$v}}}}')
                  curl -sS -H "Authorization: Bearer $GH_TOKEN" -d "$payload" https://api.github.com/graphql > /dev/null
                  updated=$((updated+1)); echo "Set Created At (DATE) → $created"
                elif [ "${AT_DTYPE:-}" = "TEXT" ] && [ -z "$haveAtText" ]; then
                  payload=$(jq -n --arg q "$UPDATE_MUT" \
                               --arg pid "$PROJECT_ID" --arg iid "$itemId" --arg fid "$AT_FIELD" --arg v "$created" \
                               '{query:$q,variables:{input:{projectId:$pid,itemId:$iid,fieldId:$fid,value:{text:$v}}}}')
                  curl -sS -H "Authorization: Bearer $GH_TOKEN" -d "$payload" https://api.github.com/graphql > /dev/null
                  updated=$((updated+1)); echo "Set Created At (TEXT) → $created"
                fi
              fi
            done

            [ "$hasNext" = "true" ] || break
          done

          echo "Scanned $scanned items, updated $updated"
