      - name: Backfill missing values (items→Issues; read fieldValues)
        if: ${{ steps.meta.outputs.project_id != '' }}
        env:
          GH_TOKEN:  ${{ secrets.PROJECTS_PAT }}
          PROJECT_ID: ${{ steps.meta.outputs.project_id }}
          BY_FIELD:   ${{ steps.meta.outputs.by_field }}
          AT_FIELD:   ${{ steps.meta.outputs.at_field }}
          AT_DTYPE:   ${{ steps.meta.outputs.at_dtype }}
        run: |
          set -e
          echo "Starting backfill for project $PROJECT_ID"

          q_items=$(cat <<'EOF'
          query($pid:ID!, $after:String){
            node(id:$pid){
              ... on ProjectV2{
                items(first:50, after:$after){
                  nodes{
                    id
                    content{
                      __typename
                      ... on Issue { id number createdAt author { login } }
                    }
                    fieldValues(first:20){
                      nodes{
                        __typename
                        field { ... on ProjectV2FieldCommon { name } }
                        ... on ProjectV2ItemFieldTextValue { text }
                        ... on ProjectV2ItemFieldDateValue { date }
                      }
                    }
                  }
                  pageInfo{ hasNextPage endCursor }
                }
              }
            }
          }
          EOF
          )

          m_update='mutation($input:UpdateProjectV2ItemFieldValueInput!){
            updateProjectV2ItemFieldValue(input:$input){ projectV2Item { id } }
          }'

          after=""
          scanned=0
          updated=0

          while : ; do
            # Build variables safely
            if [ -n "$after" ]; then
              vars=$(jq -n --arg pid "$PROJECT_ID" --arg after "$after" '{pid:$pid, after:$after}')
            else
              vars=$(jq -n --arg pid "$PROJECT_ID" '{pid:$pid}')
            fi

            body=$(jq -n --arg q "$q_items" --argjson v "$vars" '{query:$q,variables:$v}')
            resp=$(curl -s -H "Authorization: Bearer $GH_TOKEN" -d "$body" https://api.github.com/graphql)

            # If GraphQL returned errors, show them and bail
            if [ "$(echo "$resp" | jq 'has("errors")')" = "true" ]; then
              echo "::error::GraphQL errors encountered when reading project items:"
              echo "$resp" | jq -C '.errors'
              echo "::group::Full response"; echo "$resp" | jq -C .; echo "::endgroup::"
              exit 1
            fi

            # Defensive: if items is null, warn and stop (likely permissions/scope)
            if [ "$(echo "$resp" | jq -r '.data.node.items | type')" != "object" ]; then
              echo "::warning::Project items came back null. This usually means the token cannot read project items."
              echo "Ensure your PAT is a CLASSIC token with scopes: repo, workflow, project."
              echo "::group::Full response"; echo "$resp" | jq -C .; echo "::endgroup::"
              break
            fi

            hasNext=$(echo "$resp" | jq -r '.data.node.items.pageInfo.hasNextPage')
            after=$(echo "$resp" | jq -r '.data.node.items.pageInfo.endCursor // ""')

            echo "$resp" | jq -c '.data.node.items.nodes[]' | while read -r node; do
              scanned=$((scanned+1))
              type=$(echo "$node" | jq -r '.content.__typename')
              [ "$type" = "Issue" ] || continue

              itemId=$(echo "$node" | jq -r '.id')
              author=$(echo "$node" | jq -r '.content.author.login // empty')
              created=$(echo "$node" | jq -r '.content.createdAt[0:10] // empty')

              haveBy=$(echo "$node" | jq -r --arg n "Created By" '.fieldValues.nodes[]? | select(.field.name==$n) | (.text // "")' | head -n1)
              haveAtDate=$(echo "$node" | jq -r --arg n "Created At" '.fieldValues.nodes[]? | select(.field.name==$n and .__typename=="ProjectV2ItemFieldDateValue") | (.date // "")' | head -n1)
              haveAtText=$(echo "$node" | jq -r --arg n "Created At" '.fieldValues.nodes[]? | select(.field.name==$n and .__typename=="ProjectV2ItemFieldTextValue") | (.text // "")' | head -n1)

              # Created By (TEXT)
              if [ -n "$BY_FIELD" ] && [ -n "$author" ] && [ -z "$haveBy" ]; then
                payload=$(jq -n --arg q "$m_update" \
                             --arg pid "$PROJECT_ID" --arg iid "$itemId" --arg fid "$BY_FIELD" --arg v "$author" \
                             '{query:$q,variables:{input:{projectId:$pid,itemId:$iid,fieldId:$fid,value:{text:$v}}}}')
                curl -s -H "Authorization: Bearer $GH_TOKEN" -d "$payload" https://api.github.com/graphql > /dev/null
                updated=$((updated+1)); echo "Set Created By → $author"
              fi

              # Created At (DATE preferred; else TEXT)
              if [ -n "$AT_FIELD" ] && [ -n "$created" ]; then
                if [ "$AT_DTYPE" = "DATE" ] && [ -z "$haveAtDate" ]; then
                  payload=$(jq -n --arg q "$m_update" \
                               --arg pid "$PROJECT_ID" --arg iid "$itemId" --arg fid "$AT_FIELD" --arg v "$created" \
                               '{query:$q,variables:{input:{projectId:$pid,itemId:$iid,fieldId:$fid,value:{date:$v}}}}')
                  curl -s -H "Authorization: Bearer $GH_TOKEN" -d "$payload" https://api.github.com/graphql > /dev/null
                  updated=$((updated+1)); echo "Set Created At (DATE) → $created"
                elif [ "$AT_DTYPE" = "TEXT" ] && [ -z "$haveAtText" ]; then
                  payload=$(jq -n --arg q "$m_update" \
                               --arg pid "$PROJECT_ID" --arg iid "$itemId" --arg fid "$AT_FIELD" --arg v "$created" \
                               '{query:$q,variables:{input:{projectId:$pid,itemId:$iid,fieldId:$fid,value:{text:$v}}}}')
                  curl -s -H "Authorization: Bearer $GH_TOKEN" -d "$payload" https://api.github.com/graphql > /dev/null
                  updated=$((updated+1)); echo "Set Created At (TEXT) → $created"
                fi
              fi
            done

            [ "$hasNext" = "true" ] || break
          done

          echo "Scanned $scanned items, updated $updated"
